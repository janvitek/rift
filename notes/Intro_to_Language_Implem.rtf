{\rtf1\ansi\ansicpg1252\cocoartf1404\cocoasubrtf130
{\fonttbl\f0\fswiss\fcharset0 Helvetica;\f1\fmodern\fcharset0 Courier;\f2\fmodern\fcharset0 Courier-Bold;
\f3\fmodern\fcharset0 Courier-Oblique;}
{\colortbl;\red255\green255\blue255;}
\margl1440\margr1440\vieww16940\viewh14580\viewkind0
\pard\tx720\tx1440\tx2160\tx2880\tx3600\tx4320\tx5040\tx5760\tx6480\tx7200\tx7920\tx8640\pardirnatural\partightenfactor0

\f0\fs24 \cf0 Compiling a language requires understanding the semantics of the language in a deep way.  Being time limited we are going to look at Rift quickly and then focus on the interesting features.\
\
One traditional way to view a language is by looking at the grammar.\

\f1\fs32 \
SEQ        ::= 
\f2\b \{
\f1\b0  
\f3\i \{ STMT \}+
\f1\i0  
\f2\b\fs34 \}
\f1\b0\fs32 \
STMT       ::= 
\f3\i IF
\f1\i0  | 
\f3\i WHILE
\f1\i0  | 
\f3\i EXP
\f1\i0 \
EXP        ::= 
\f3\i E1
\f1\i0  
\f3\i \{
\f1\i0  
\f3\i (
\f1\i0  
\f2\b ==
\f1\b0 |
\f2\b !=
\f1\b0 |
\f2\b <
\f1\b0 |
\f2\b >
\f1\b0  
\f3\i )
\f1\i0  
\f3\i E1
\f1\i0  
\f3\i \}
\f1\i0 \
E1         ::= 
\f3\i E2
\f1\i0  
\f3\i \{
\f1\i0  
\f3\i (
\f1\i0  
\f2\b +
\f1\b0 |
\f2\b -
\f1\b0  
\f3\i )
\f1\i0  
\f3\i E2 \}
\f1\i0 \
E2         ::= 
\f3\i E3
\f1\i0  
\f3\i \{
\f1\i0  
\f3\i (
\f1\i0  
\f2\b *
\f1\b0 |
\f2\b /
\f1\b0  
\f3\i )
\f1\i0  
\f3\i E3
\f1\i0  
\f3\i \}
\f1\i0 \
E3         ::= 
\f3\i F
\f1\i0  \{ 
\f3\i INDEX
\f1\i0  | CALL | 
\f3\i ASSIGN
\f1\i0  \}\
F          ::= 
\f3\i NUMBER
\f1\i0  | 
\f3\i STRING
\f1\i0  | 
\f3\i IDENT
\f1\i0  | 
\f3\i FUNCTION
\f1\i0  | \
               
\f3\i SPECIAL_CL
\f1\i0  | 
\f2\b (
\f1\b0  
\f3\i EXP
\f1\i0  
\f2\b )
\f1\b0 \
CALL       ::= 
\f2\b (
\f1\b0  
\f3\i EXP
\f1\i0  \{, EXP \}+ 
\f2\b )
\f1\b0 \
INDEX      ::= 
\f2\b [
\f3\i\b0 EXP
\f1\i0  
\f2\b ]
\f1\b0  [ 
\f3\i ASSIGN
\f1\i0  ]\
ASSIGN     ::=  
\f2\b <-
\f1\b0  EXP\
SPECIAL_CL ::= 
\f3\i EVAL
\f1\i0  | 
\f3\i LENGTH
\f1\i0  | 
\f3\i TYPE
\f1\i0  | 
\f3\i C
\f1\i0 \
EVAL       ::= 
\f2\b eval(
\f3\i\b0 EXP
\f2\i0\b )
\f1\b0 \
LENGTH     ::= 
\f2\b length(
\f3\i\b0 EXP
\f2\i0\b )
\f1\b0 \
TYPE       ::= 
\f2\b type(
\f3\i\b0 EXP
\f2\i0\b )
\f1\b0 \
C          ::= 
\f2\b c(
\f1\b0  
\f3\i EXP\{, EXP\}+
\f1\i0  
\f2\b )
\f1\b0 \
FUNCTION   ::= 
\f2\b function(
\f3\i\b0 [ident\{, ident \}+]
\f2\i0\b )
\f1\b0  
\f3\i SEQ
\f1\i0 \
WHILE      ::= 
\f2\b while
\f1\b0 (
\f3\i EXP
\f2\i0\b )
\f1\b0  
\f3\i SEQ
\f1\i0 \
IF         ::= 
\f2\b if(
\f3\i\b0 EXP
\f2\i0\b )
\f1\b0  
\f3\i SEQ
\f1\i0  [ 
\f2\b else
\f1\b0  
\f3\i SEQ
\f1\i0  ]\
\
\pard\tx720\tx1440\tx2160\tx2880\tx3600\tx4320\tx5040\tx5760\tx6480\tx7200\tx7920\tx8640\pardirnatural\partightenfactor0

\f0\fs24 \cf0 But a grammar only gets you so far. The better way to start is with the data.\
\
1+2\
x[32]\
x <- function()\{\}\
a<b    # returns vector with either 1 or 0\
type(s)  # string\
\
what are the data types?\
\
double\
string\
function?\
boolean?\
\
double ==> vector of double\
string ==> vector of character\
function\
boolean -> no vector of 1 double\
\
\
TALK \'97 Environment\
TALK \'97 Pool\
\
\
}